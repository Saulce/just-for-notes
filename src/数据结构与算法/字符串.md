# 字符串

## KMP 算法

用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ，而空间复杂度也只有 O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而 KMP 算法可以利用**已经部分匹配**这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。

假如在匹配的过程中发现正在比较的两个字符不同（称之为失配），那么朴素的算法会将模版串右移一位，重新比较。而KMP算法认为，既然失配部分前面的字符（区域S1）已经比较过了，那么就不应该再比较一次。那么该从哪里开始重新比较呢？KMP算法针对搜索词，可以算出一张《部分匹配表》(Partial Match Table)，按照公式算出向后移动的位数：移动位数 = 已匹配的字符数 - 对应的部分匹配值.

#### 部分匹配表如何产生?

"前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。"部分匹配值"就是"前缀"和"后缀"的**最长的共有元素**（最长相等前后缀）的长度。

### next数组

next数组就是一个前缀表（prefix table）。**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配**。

#### 前缀表是如何记录的呢？

记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**

#### 如何计算前缀表

找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。所以要看前一位的 前缀表的数值。

**next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**针对前缀表到底要不要减一，这其实是不同KMP实现的方式

#### 构造next数组

主要有如下三步：

1. 初始化：定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）所以初始化next[0] = j 
2. 处理前后缀不相同的情况：因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。遇到前后缀末尾不相同的情况，就要向前回退。next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。
3. 处理前后缀相同的情况：如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。

### <u>实现 strStr()</u>

在一个串中查找是否出现过另一个串，这是KMP的看家本领。

**使用next数组来做匹配**。

### BM 算法

BM 算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。

## 反转字符串

**如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。** **如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**

1. 调用库函数 reverse()
2. 双指针循环中调用库函数 swap()
3. 依靠 ^= 或 temp 实现

### 反转字符串II 

—— 简单的反转还不够，我要花式反转

在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。

**所以当需要固定规律一段一段去处理字符串的时候，要想想在for循环的表达式上做做文章。**

这里具体反转的逻辑要不要使用库函数呢，其实用不用都可以，使用reverse()来实现反转也没毛病，毕竟不是解题关键部分。

## 最长公共前缀

1. 横向扫描

   依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。

2. 纵向扫描

   纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。

3. 分治

4. 排序数组中的字符串然后对比第一个和最后一个的前缀

字符串排序的基本规则：字符串将根据ASCII码值进行升序排序。如果字符串的前缀相同，长度不同，较短的字符串会排在较长的字符串前面。

## 替换字符

### 替换空格

1. 常规方法。利用`String.charAt(i)`以及`String.valueOf(char).equals(" ")`遍历字符串并判断元素是否为空格。是则替换，否则不替换
2. 利用API替换掉所用空格，一行代码解决问题`.toString().replaceAll()`

### 替换数字

如果想把这道题目做到极致，就不要只用额外的辅助空间了！（不过使用Java刷题的话，一定要使用辅助空间，因为Java里的string不能修改）

首先扩充数组到每个数字字符替换成 "number" 之后的大小。然后从后向前替换数字字符，也就是双指针法，过程：i指向新长度的末尾，j指向旧长度的末尾。

为什么要从后向前填充，从前向后填充不行么？

从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。**其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

#### 字符串和数组有什么差别？

字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定。

## 翻转字符串里的单词

这道题目可以说是综合考察了字符串的多种操作。如果使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。所以提高一下本题的难度：**不要使用辅助空间，空间复杂度要求为O(1)。**

不能使用辅助空间，只能在原字符串上下功夫了。通过 **先整体反转再局部反转**，实现反转字符串里的单词。

- 移除多余空格
- 将整个字符串反转
- 将每个单词反转

## 右旋字符串

字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。

提升一下本题难度：**不能申请额外空间，只能在本串上操作**。 （Java不能在字符串上修改，所以使用java一定要开辟新空间）

思路与上类似，先整体反转后局部反转就可以实现。

剑指offer的题目是*左反转*：通过**先局部反转再整体反转**达到左旋的效果。

## 重复的子字符串

**移动匹配**

当一个字符串内部由重复的子串组成，那么这个字符串的结构一定是由前后半相同的子串组成。那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串的前半部分，和前面的子串的后半部分，就一定还能组成一个s，即为 s + s 组成的字符串中一定有子串s 。

当然，为了避免在s+s中搜索出原来的s，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，确保我们搜索到的是中间拼接出来的s。

## 回文串

### 最长回文串

### 验证回文串

## 括号匹配深度

## 把字符串转换成整数

即实现 `Integer.valueOf(string)`的功能