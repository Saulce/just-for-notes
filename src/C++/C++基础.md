# C++

## 内存四区

不要返回局部变量的地址，不要返回局部变量的引用。

函数参数由编译器在栈区开辟内存；堆区由程序员用new()开辟内存。使用delete释放内存。

指针本质也是局部变量，放在栈区，指针指向的数据在堆区。

static修饰的静态变量放在全局区——将局部变量变为全局变量。

const修饰形参，防止形参改变实参的误操作——常量引用。

## 函数

函数调用可以作为左值。

函数形参可以有默认值，不影响外部赋值。占位参数（只写数据类型）也可以有默认值，但必须在调用时填补。

使用初始化列表初始化属性：`函数名() : 属性1(值1), 属性2(值2), ...;`

函数调用通过：1. 对象.函数名  2. 类名::函数名

### 函数重载

需满足条件：

1. 同一作用域下
2. 函数名相同
3. 函数参数类型不同 或 参数个数不同 或 参数顺序不同
4. ps. 返回值不可以作为重载条件

函数重载可以 **&a（用变量传递）**和 **const &a（用常量传递）**重载。

重载最好不加默认参数。

## 封装

`class 类名 { 访问权限 : 属性 / 行为 };`

三种权限：

1. public        类内可访问        类外可访问
2. protected        类内可访问        类外不可访问（儿子可以访问父亲）
3. private        类内可访问        类外不可访问（儿子不可以访问父亲）

**区别：**struct默认访问权限为public，class默认访问权限为private

成员属性设置为私有，通过公共权限的函数作接口进行读写

### 构造函数

**构造函数：**`类名() {};`	可以有参数，因此可以重载

**析构函数：**`~类名() {};`	不可以含参，不可以重载

构造函数的调用：

- 括号法
- 显示法（匿名对象，不要拷贝构造）
- 隐式转换法

#### 拷贝构造函数

`类名( const 类名 &对象 ) {};`

调用时机：1. 值方式返回局部对象  2. 值传递方式给函数参数传值

**浅拷贝：**简单的赋值拷贝操作（堆区内存重复释放问题）

**深拷贝：**在堆区重新申请空间进行拷贝操作（析构作用）	浅拷贝的问题用深拷贝解决（使用指针等时）

### 成员变量

对象成员先于本类对象构造，析构顺序相反。

#### 静态成员变量

成员函数与成员变量分开存储

- 所有对象共享同一份数据
- 在编译阶段分配内存
- 类内声明，类外初始化 `数据类型 类名::变量 = 值;`

#### 静态成员函数

每个非静态函数共享同一函数实例

- 所有对象共享同一个函数
- 静态成员函数只能访问静态成员变量（不属于任何一个对象）

**this指针**指向被调用的成员函数所属对象（指向不可修改），指针对象调用时使用 '->'，空指针调用成员函数需要注意this指针。

#### const常函数

成员函数后 + const

- 不可修改成员属性
- 成员属性声明时加关键字 mutable 后可修改

#### const常对象

- 只能调用常函数，因此不可修改成员属性（mutable 除外）
- 声明对象前 + const

### 友元 friend

类中声明

- 全局函数
- 友元类
- 成员函数

### 运算符重载

`类名 operator 运算符 (类名 &对象名)(通过成员) (类1 &对象1, 类2 &对象2)(通过全局函数);`

## 继承

`class 子类(派生类) : 继承方式 父类(基类);`

- 公有继承public：权限不变
- 保护继承protected：public、protected权限变为protected
- 私有继承private：权限全变为private

父类的私有成员只是被隐藏了，还是会继承给子类。

<u>利用开发人员命令提示工具查看对象模型</u>

子类继承父类后，当创建子类对象时，也会调用父类的构造函数。

父类构造 -> 子类构造 -> 子类析构 -> 父类析构

子类对象访问父类继承下来的同名成员，需要加作用域。  `子类对象.父类::属性/函数`

如果子类中出现和父类同名的成员函数，子类的同名函数会隐藏掉父类中所有的同名函数（包括重载的），若想访问，加作用域。

静态成员与非静态出现同名，处理方式一致 ↑ 。

### *多继承

`class 子类 : 继承方式 父类1, 继承方式 父类2, ...;`

C++实际开发中*不建议*使用多继承

多继承引发的父类中出现同名成员，需要加作用域区分。

### 菱形继承

两个派生类继承用一个基类，又由某个类同时继承这两个派生类

#### 问题

1. 数据产生二义性
2. 最后继承自基类的数据有两份，但仅需一份

#### 解决方法

虚继承	`class 子类 : virtual 继承方法 父类(虚基类);`

**vbptr 虚基类指针：**在子类中替代成员（父类继承下来的），指向 **vbtable** ，查表偏移量找到唯一的数据的地址

## 多态

**静态多态：**函数、运算符重载

**动态多态：**派生类和虚函数

**区别：**静态多态的函数地址早绑定——编译阶段；动态多态的函数地址晚绑定——运行阶段

**优点：**

- 代码组织结构清晰
- 可读性强
- 利于前后期的扩展及维护
  - 开闭原则：对扩展进行开放，对修改进行关闭

### 虚函数

virtual 函数——虚函数（父类）

动态多态条件：

- 有继承关系
- 子类要重写父类中的虚函数        重写：完全相同（子类的virtual关键字可有可无）

#### 动态多态的使用

父类的指针或引用指向子类对象

《VS的开发人员命令提示符 Command Prompt》	vfptr 虚函数（表）指针 -> vftable 虚函数表（表内记录虚函数的地址）

当子类重写了父类的虚函数：子类中的虚函数表内部会替换成子类的虚函数地址——当父类指针或引用指向子类对象时，发生多态。

#### 纯虚函数

`virtual 返回值类型 函数名(参数) = 0`

此时所在类也称为抽象类：无法实例化；其子类必须重写父类中的纯虚函数，否则也属于抽象类

**虚析构：**`virtual ~函数名() {};`

**纯虚析构：**`virtual ~函数名 () = 0;`	需要在外部再添加函数的实现	`作用域::~函数名() {}`也属于抽象类

虚析构函数与纯虚析构函数**共性：**

- 都可以解决父类指针无法释放子类对象的问题——父类指针在析构时不会调用子类中的析构函数，导致子类如有堆区属性，会出现内存泄漏，虚析构父类指针则会调用子类析构
- 都需要有具体的函数实现

## 文件

头文件 <fstream>

ofstream 写操作	ifstream 读操作	fstream 读写操作

打开方式：ios :: in 读	out 写	ate 初始位置为文件尾	app 追加方式写	trunc 先删除后创建	binary 二进制方式

ps. 可以使用 '|' 操作符配合使用打开方式

1. `ofs << ... << endl;`
2. `ifs >> 数组1; cout << 数组1 << endl;`
3. `ifs.getline(数组1, sizeof(数组1));`
4. `while(getline(ifs, 数组1)); cout << 数组1 << endl; `
5. 逐字符读（不推荐）

二进制文件，不仅可以写入默认数据类型，也可以自定义数据类型。

```c++
ofs.write( const char * buffer, int len );

ifs.read( char * buffer, int len );
```

## 泛型编程

### 模板

#### 函数模板

函数返回值类型和形参类型可以用一个虚拟的类型来代表

```c++
template <typename/class T>  #通用数据类型，可以替换，通常为大写字母
函数声明或定义;    
```

使用函数模板：

1. 自动类型推到：根据传参的数据类型保持一致
2. 显示指定类型：函数名<数据类型>(参数1, 参数2)；

普通函数调用时可以发生隐式类型转换，函数模板的自动类型推导不会。

特性：

- 优先调用普通函数
- 可以通过空模板参数列表强制调用函数模板——空模板参数列表：`函数名<> (参数1, 参数2);`
- 函数模板也可以重载
- 若函数模板可以产生更好的匹配则优先调用函数模板
- 模板无法实现数组、自定义数据类型等

#### 类模板

作用：建立一个通用类，类中成员数据类型可以不具体指定

```c++
template <typename T(T1, T2, ...)(是虚拟数据类型)>

类定义;
```

与函数模板的**区别**：

- 类模板没有自动类型推导
- 类模板在模板参数列表中可以有默认参数——如：<typename T = int>

普通类中成员函数一开始就可以创建，类模板中则在调用时才创建

类模板作函数参数：

1. 指定传入的数据类型
2. 参数模板化
3. 整个类模板化

查看参数的数据类型：`typeid(T).name();`

当子类继承的父类是一个类模板时，子类在声明时要指出父类中 T 的类型。

若想要灵活的指定父类中 T 的类型，子类也需要变为类模板。如：`class Son : public Base <int>;` 又如：`template <class T> class Son : public Base <T>;`

类模板成员函数的类外实现：

```c++
template <class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{ }
```

类模板分文件编写时链接不到成员函数，因为其创建在调用阶段。解决方法：

1. 直接包含.cpp源文件（不常用）
2. 将声明 .h 与实现 .cpp 写在同一个文件中，并更改后缀名为 .hpp

类模板类内实现友元：直接类内声明全局函数友元；类外：需要提前让编译器知道全局函数的存在 `friend void 函数模板名<>(P<> p);`

### STL

**六大组件：**容器（用来存放数据）、算法、迭代器（作用于容器与算法间）、仿函数、（适配器、空间配置器）

#### Vector容器

可以理解为数组

通过迭代器访问容器中的数据：`vector <int> :: iterator itBegin = v.begin(); #起始迭代器 / itEnd = v.end(); #结束迭代器，指向容器中最后一个元素的下一个位置`

3种遍历方法

容器嵌套容器：`vector <vector <int>> v;` 相当于二维数组

#### String容器

vector和数组的区别：数组是静态空间，vector容器（又称单端数组）可以动态扩展

动态扩展并非在原空间后续接新空间，而是找个更大的空间，然后将原数据拷贝至其中，最后释放原空间。

vector 互换容器 v.swap() 巧用可以收缩内存空间：`vector <int> (v).swap(v);`

#### deque容器

又称双端数组，还可以对头端进行插入删除操作

#### stack容器

栈不允许有遍历行为，只允许访问栈顶元素，先进后出

常用接口（对外）

#### queue容器

队列不允许有遍历行为，只有队头和尾能被访问，先进先出

#### list容器

双向循环链表

list和vector是最常用的两个容器，各有优缺点：list的插入操作和删除操作都不会造成原有list迭代器失效，这在vector种不成立。

list本质是链表，不是用连续线性空间存储数据，迭代器也不支持随机访问；即不可用L[o] 及 L.at(o) 来访问。所有不支持随机访问迭代器的容器，不可以用标准算法，其内部会提供一些对应的算法。

#### set/multiset容器

属于关联式容器，用二叉树实现底层结构

所有元素在被放入时会自动被排序；插入的同时会返回插入结果，表示插入是否成功

- set容器不允许有重复元素
- multiset容器不会检测数据，因而允许重复

#### map/multimap容器

map种所有元素都是pair

pair中第一个元素为key，索引作用，第二个为value实值。

所有元素会根据key自动排序

- map容器不允许重复元素
- multimap容器可以有重复key值的元素

本质：同set容器

不建议使用 [] 插入，但可以 [key] 访问到value

#### 函数对象

重载函数调用符 () 的类，本质上是一个类，其对象称为函数对象，又称仿函数

**谓词 Pred：**返回bool类型的仿函数

**内建函数对象：**算术仿函数、关系仿函数、逻辑仿函数

<algorithm>（STL头文件中最大，范围涉及广）	<functional>（定义一些模板类，用以声明函数对象）	<numeric>（体积很小，简单运算）

#### 常用遍历算法

- for_each  遍历容器

- transform  搬运容器到另一容器中

#### 常用查找算法

- find

- find_if
- adjacent_find
- binary_search
- count
- count_if

#### 常用排序算法

- sort
- random_shuffle
- merge
- reverse

#### 常用拷贝和替换算法

- copy
- replace
- replace_if
- swap

#### 常用算术生成

- accumulate
- fill

#### 常用集合算法

- set_intersection
- set_union
- set_difference

## 异常

### 异常处理

抛出异常 throw	捕获异常 catch

```c++
try{
    可能引发异常的代码;
}
catch(){
    所有其他情况，例外
}
```

自定义/标准异常类，都继承自 std::exception——std::runtime_error / std::invalid_argument / std::out_of_range

### 异常传播