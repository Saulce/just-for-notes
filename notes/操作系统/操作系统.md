# 操作系统

操作系统到底是什么：

1. 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。
2. 操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。
3. 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。
4. 操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

**功能：**

1. **进程和线程的管理**：进程的创建、撤销、阻塞、唤醒，进程间的通信等。

2. **存储管理**：内存的分配和管理、外存（磁盘等）的分配和管理等。

3. **文件管理**：文件的读、写、创建及删除等。

4. **设备管理**：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。

5. **网络管理**：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。

6. **安全管理**：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。

**内核 Kernel ：**

- 进程、线程
- 内存
- 硬件设备
- 系统调用

**局部性原理：**

- 程序数据引用的局部性
- 取指令的局部性

### 用户态和内核态

- **用户态(User Mode)** : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。
- **内核态(Kernel Mode)**：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。

内核态相比用户态拥有更高的特权级别，因此能够执行更底层、更敏感的操作。不过，由于进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。

#### 为什么要有用户态和内核态？只有一个内核态不行么？

- 在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 **特权指令** 。
- 如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。

因此，同时具有用户态和内核态主要是为了保证计算机系统的安全性、稳定性和性能。

**用户态切换到内核态的 3 种方式：**

1. **系统调用（Trap）**：用户态进程 **主动** 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。
2. **中断（Interrupt）**：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
3. **异常（Exception）**：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

在系统的处理上，中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。

## 硬件

### CPU

**优化代码 -> 执行更快 -> 配合CPU Cache工作机制（缓存高命中率），**如：

遍历数组时，按<u>内存布局顺序</u>，可以有效利用Cache，性能提升大。

先排序再遍历要快于反之。

分支预测器：若肯定if表达式中true概率更高，可以用 likely 宏把表达式包裹起来，反之用 unlikely 宏。

为了防止（多个同时执行的计算密集型线程）（多核CPU）切换到不同的核心导致缓存命中率下降的问题，可以把线程绑定在一个CPU核心上，因而Linux上提供了 sched_setaffinity 方法。

**MESI协议：**写直达、写回、写传播——总线嗅探、事物的串行化

**避免伪共享：**Linux内核中存在 _cacheline_aligned_in_smp 宏定义，将另一变量地址设置为Cacheline对齐地址

**硬中断/软中断：**主要是完成硬中断未完成的工作

### 设备管理

#### 键盘输入 & 在此期间操作系统发生了什么？

键入键盘字符 -> 键盘控制器产生扫描码数据，并缓冲在其寄存器中 -> 键盘控制器通过总线给CPU发送中断请求 -> 保存被中断进程的CPU上下文 -> 调用键盘的中断处理程序 -> 获取显示字符的ASCII码并放至读缓冲区队列 -> 从读缓冲区中读取数据放到写缓冲区队列 -> 将写缓冲区的数据一个个写入到显示设备的控制器的寄存器中的数据缓冲区 -> 显示在屏幕上 (-> 恢复被中断进程的上下文)

## 内存

**外部内存碎片 <-解决- 内存交换（Linux系统中的Swap空间）——内存交换效率低 <-解- 内存分页**

### 分页

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。

**内部内存碎片 <-解- 换入换出（内存交换效率相对较高）**

**页表空间过大 <- 多级页表 <- 四级目录**：{PGD 全局页目录项、PUD 上层、PMD 中层、PTE 页表项}

#### 段页式内存管理

**TLB 页表缓存：**把最常访问的几个页表项存储到Cache中

### 虚拟内存

**作用：**

1. 可以使进程对运行内存超过物理内存大小，未访问内存可以换出至硬盘上
2. 每个进程虚拟内存空间相互独立，不会出现多进程地址冲突问题
3. 更好的安全性

malloc 函数申请内存时申请的是虚拟内存。

Redis——LFU算法，MySQL和Linux——LRU算法

## 进程、线程

### 进程

被装载到内存中后，CPU执行该程序的每一条指令，那么这个运行中的程序被称为进程。

**并发：**通过中断实现多个程序交替执行的想法

**PCB（进程控制块）**是进程存在的唯一标识，包含：进程标识符、用户标识符、进程当前状态、进程优先级、有关内存地址空间或者虚拟地址空间的信息、CPU中各个寄存器的值

通过链表方式进行组织。

**CPU上下文切换：**进程 / 线程 / 中断 上下文切换

#### 进程间的通信方式

**管道（传输数据是单向的）**	先进先出原则

通过 mkfifo 命令创建命名管道，可以在不相关的进程间相互通信。（"|" 匿名管道，用完即销毁，范围仅存在父子关系间）

只有当管道里的数据被读完后，命令才可以正常退出。因而效率低，不适合进程间频繁的交换数据。

*所谓管道，实际上就是内核里的一串缓存。*

#### 消息队列

是保存在内核中的消息链表。

不适合传输较大的数据。存在用户态与内核态间的数据拷贝开销 -解-> 共享内存

可能冲突，导致覆盖前一个进程的写入，需要保护机制 ↓

**信号量：**是一个整型计数器，主要用于实现进程间的互斥与同步，而非用于缓存进程间通信的数据。

kill -l  命令查看所有信号

### 线程

线程间可以并发运行且共享相同的地址空间，线程是进程中的一条执行流程。

**缺点：**当进程中一个线程崩溃时会导致所属所有线程崩溃（针对C / C++）

当进程仅有一个线程时，可以认为进程等于线程。

进程是资源分配的单位，线程是CPU调度的单位，所以，操作系统的任务调度，实际上调度对象是线程，进程只是给线程提供了虚拟内存、全局对象等资源。

**线程的上下文切换**

**三种线程实现方式：**

1. 用户线程↓	多对一、一对一、多对多
2. 内核线程
3. 轻量级线程

#### 多线程冲突

临界区是互斥的

**进/线程同步：**并发进/线程在一些关键点上可能需要互相等待与互通

**消息** —方法—：

- 锁：解决互斥问题
- 信号量：实现临界区的互斥访问

#### 经典同步问题

- 生产者—消费者问题
- 哲学家就餐问题
- 读者—写者问题

一个进程最多可以创建多少个线程？

#### 死锁

两个线程都在等待对方释放锁的情况，同时满足四个条件：

1. 互斥条件
2. 持有并等待条件
3. 不可剥夺条件
4. 环路等待条件

ps. 使用jstack工具排查java程序是否死锁；Linux下的c++使用pstack + gdb，方式：pstack<pid>

**使用资源有序分配法来避免死锁！**

**(互斥锁、自旋锁)(最底层)、读写锁、悲观锁、乐观锁**

- 被锁住的代码执行时间很短 -> 不用互斥锁用自旋锁
- 读写锁适用于能明确区分读和写操作的场景、读多写少的场景
- 公平读写锁较简单的方式：用队列把获取锁的线程排队
- 只有在冲突概率非常低，且加锁成本非常高的情况下才考虑乐观锁（在线文档等）

#### 协程

一种用户态的轻量级线程，它的调度和切换完全由程序控制，不依赖于操作系统的调度。协程之间共享线程的资源，因此协程间的通信也可以通过共享变量、锁等方式进行。协程的优势在于能够轻松实现高并发，适用于I/O密集型任务，通过异步I/O可以有效提高程序性能。

## 调度

### 调度原则

### 调度算法

- 进度调度算法
  - 先来先服务
  - 最短作业优先
  - 高响应比优先
  - 时间片轮转
  - 最高优先级
  - 多级反馈队列
- 内存页面置换算法
  - 最佳页面置换 OPT
  - 先进先出置换 FIFO
  - 最近最久未使用 LRU
  - 时钟页面置换 Lock
  - 最不常用 LFU

- 磁盘调度算法
  - 先来先服务
  - 最短寻道时间优先
  - 扫描
  - 循环扫描
  - LOCK与C-LOCK

## 文件系统

### 文件传输

DMA (直接内存访问) 技术

#### 优化文件传输性能

- 减少上下文切换次数——减少系统调用次数

- 减少数据拷贝次数 -> 用户空间的缓冲区没有必要存在 -> 零拷贝（2种方式实现）

  - mmap + write，用 mmap() 替换 read() 系统调用函数
  - sendfile，用 sendfile() 取代 read() 和 write() 两个系统调用函数

  Kafka 开源项目就用到了零拷贝技术

### 虚拟文件系统 VFS

目录是个文件，存储在磁盘；目录项是内核的一个数据结构，缓存在内存

- 磁盘的文件系统：Ext2/3/4、XFS等

- 内存的文件系统：/proc、/sys，读写这类文件，实质上是读写内核中的相关数据

- 网络的文件系统：用以访问其他计算机主机的数据，如NFS、SMB等

文件系统首先要挂载到某个目录才能正常使用

文件系统的基本操作单位是数据块

**文件存储：**连续 / 非连续空间存放方式、Unix文件实现方式

**空闲空间管理：**空闲表法、空闲链表法、位图法（被Linux文件系统采用）

### 文件系统结构

#### 块组

[引导块  1K] [块组0] [块组1 ↓] ...

- [超级块  1块] [块组描述符表  多块] [数据位图  1块] [inode位图  1块] [inode列表  多块] [数据块  多块]

#### 稀疏技术

**目录存储：**普通文件的块保存的是文件数据，目录文件的块保存的是目录里的一项项的文件信息。格式可为哈希表。

#### 软硬链接

### 文件I/O

- 缓冲与非缓冲IO
- 直接与非直接IO
- 阻塞与非阻塞IO  VS  同步与异步IO

### Page Cache

通过读取 /pro/meminfo 实时获取系统内存情况

Page Cache = Buffers + Cached + SwapCached = Active(file) + Inactive(file) + shmem + SwapCached

page是内存管理分配的基本单位。

Page Cache 由多个page组成，另外，并非所有page都被组织为Page Cache。

**File-backed pages：**文件备份页，即为Page Cache中的page，**Anonymous pages：**匿名页不对应磁盘上任何的磁盘数据块

Page Cache 用于缓存文件的页数据，（近似的融合了）buffer cache 用于缓存块设备的块数据。

内存空间<u>回收</u>的方式通常是 <u>swap</u>

缺页中断 -> 页面替换

#### 预读机制

#### 文件一致性 & 可靠性

文件 = 数据 + 元数据（用来描述文件的各种属性）

Write Through  写穿

Write Back  写回

## 网络系统

Socket 插口	IPv4

使用socket通信来跨网络与不同主机上的进程通信

针对 TCP	UDP	本地通信的socket编程