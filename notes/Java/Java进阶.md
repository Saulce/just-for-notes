# Java

## 集合框架

### 单列集合——Collection 接口

主要用于存放单一元素

Collection 是单列集合的祖宗接口，其功能全部单列集合都可以继承使用

**体系结构：**

- **List** (接口)——有序（存取同序）、可重复、有索引

  **特有方法**：`void add(int index, E element)	E remove(int index)	E set(int index, E element)	E get(int index)`

  **遍历方式**：迭代器遍历	列表迭代器遍历 ListIterator	增强for遍历	Lambda表达式遍历	普通for遍历（因为List存在索引）

  - ArrayList (实现类)	底层是数组结构
  - LinkedList (实现类)        底层是双链表结构

- **Set** (接口)——无序、不可重复、无索引

  - HashSet (实现类)——无序、不重复、无索引	底层采取哈希表存储数据
    
    - LinkedHashSet (实现类)——有序（指保证存储和取出元素的顺序一致）、不重复、无索引	底层是哈希表，每个元素又多了个双链表机制记录存储的顺序
    
  - TreeSet (实现类)——可排序、不重复、无索引	底层是红黑树
  
    比较方式：
  
    1. 默认/自然排序：Javabean类实现**Comparable接口**指定比较规则
  
    2. （当第一种不能满足时，使用第二种）比较器排序：创建TreeSet对象时，传递**比较器Comparator**指定规则（当两种方式同时存在，以方式二为准）
  
    方法返回值特点：
  
    - 负数：表示当前要添加的元素是小的，存左边
    - 正数：表示当前要添加的元素是大的，存右边
    - 0：表示当前要添加的元素已存在，舍弃
  
- Queue

**遍历**

- 迭代器遍历（不依赖索引）

`Iterator<E> iterator()`	返回迭代器对象，默认指向当前集合的0索引

迭代器常用方法：

`boolean hasNext()`	判断当前位置是否有元素，有元素返回true，没元素返回false

`E next()`	获取当前位置元素，并将迭代器对象移向下一个位置

p.s.  1. 迭代器遍历完毕，指针不会复位

​	2. 循环中只能用一次next()方法

​	3. 迭代器遍历时，不能用集合的方法进行增加或删除

- 增强for遍历

底层就是迭代器，为了简化迭代器的代码而生。适用于所有的单列集合和数组。

`for(数据类型 变量名 : 数组或单列集合){}`

快速生成方法：集合的名字`.for + 回车`

增强for中的变量是第三方变量，修改它并不会改变集合中原本的数据

- Lambda表达式遍历

更简单更直接

`.forEach()	# 是语法糖`

#### List 集合

- Collection 的方法List都继承了
- List 集合因为有索引，所以多了很多索引操作的方法

**遍历**

- 迭代器遍历——在遍历的过程中需要删除元素
- 列表迭代器遍历——在遍历的过程中需要添加元素
  - 在迭代器的基础上额外添加了一个方法：add() 在遍历的过程中，可以添加元素
- 增强for遍历——仅仅想遍历
- Lambda表达式遍历——同上
- 普通for遍历——在遍历时想操作索引

特殊用法：将`list.addAll()`与`List.of()`结合使用更加简便。

#### Set 集合

哈希表组成：JDK8之后：数组+链表+红黑树——当链表长度超过8，且数组长度 >= 64时，自动转换为红黑树

新元素存入（JDK8以后：直接挂在老元素下面）

哈希值：对象的整数表现形式

- 根据 hashCode 方法算出来的 int 类型整数
- 该方法定义在 Object 类中，所有对象都可以调用，默认使用地址值进行计算
- 一般情况下，会重写 hashCode 方法，利用对象内部的属性值计算哈希值

对象哈希值的特点：

- 如果没有重写 hashCode 方法，不同对象计算出的哈希值是不同的
- 如果已经重写 hashCode 方法（IDEA 帮忙重写），不同对象只要属性值相同，计算出的哈希值就是一样的（如果集合中存储的是自定义对象，必须要重写 hashCode 方法和 equals 方法）
- 哈希碰撞

**HashSet 的三个问题？**

1. HashSet 为什么存和取的顺序不一样？

2. HashSet 为什么没有索引？

   不够纯粹，由链表、数组、红黑树共同组成

3. HashSet 利用什么机制保证数据去重？

   HashCode 方法和 equals 方法

**LinkedHashSet：**其内部是通过 `LinkedHashMap` 来实现的。

**TreeSet 的排序方式**

对于数值类型，默认从小到大排序；对于字符、字符串类型，按照字符在ASCII码表中的数字升序进行排序

#### 应用场景

1. 如果想要集合中的元素可重复——ArrayList
2. 如果想要集合中的元素可重复，而且当前的增删操作明显多于查询——LinkedList
3. 如果想要对集合中的元素去重——HashSet
4. 如果想对集合中的元素去重，且想保证存取顺序——LinkedHashSet
5. 如果想对集合中的元素进行排序——TreeSet

#### Deque

Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。

Deque有三种用途：

- 普通队列(一端进另一端出):
  Queue queue = new LinkedList()或Deque deque = new LinkedList()
- 双端队列(两端都可进出)
  Deque deque = new LinkedList()
- 堆栈
  Deque deque = new LinkedList()

注意：Java堆栈 Stack类 已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。

Deque是一个线性collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“dek”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。

#### CopyOnWriteArrayList

在 JDK1.5 之前，如果想要使用并发安全的 `List` 只能选择 `Vector`。而 `Vector` 是一种老旧的集合，已经被淘汰。`Vector` 对于增删改查等方法基本都加了 `synchronized`，这种方式虽然能够保证同步，但这相当于对整个 `Vector` 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。JDK1.5 引入了 `Java.util.concurrent`（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 `List` 实现就是 `CopyOnWriteArrayList` 。

对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该允许多个线程同时访问 `List` 的内部数据，毕竟对于读取操作来说是安全的。这种思路与 `ReentrantReadWriteLock` 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（只有读读不互斥）。`CopyOnWriteArrayList` 更进一步地实现了这一思想。为了将读操作性能发挥到极致，`CopyOnWriteArrayList` 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。

**Copy-On-Write 的思想**

`CopyOnWriteArrayList` 线程安全的核心在于其采用了 **写时复制（Copy-On-Write，简称 COW）** 的策略，从 `CopyOnWriteArrayList` 的名字就能看出了。

COW是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。

不过，写时复制机制并不是银弹，其依然存在一些缺点，下面列举几点：

1. 内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。
2. 写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。
3. 数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。
4. ……

### 双列集合——Map 接口

主要用于存放键值对

**特点：**

1. 双列集合一次需要存一对数据，分别为键和值
2. 键不能重复，值可以重复
3. 键和值一一对应
4. 将“键 + 值”这个整体称为“键值对”或“键值对对象”，在Java中称为“Entry对象”

#### Map

是双列集合的顶层接口，它的功能是全部双列集合都可以继承使用的 `Map<K,V>`

特点都是由键决定的：无序、不重复、无索引

put 方法的细节：

- 添加：在添加数据时，如果键不存在，直接把键值对对象添加到 map 集合当中，并返回 null
- 覆盖：如果键存在，会把原有的键值对对象覆盖，然后返回被覆盖的值

**遍历**

1. 键找值：

   1. 获取所有的键，把这些键放到一个单列集合当中 `keySet()`
   2. 遍历单列集合，得到每一个键
   3. 利用 map 集合中的键获取对应的值 `get()`

2. 键值对：

   1. 通过`entrySet()`方法获取所有的键值对对象，返回一个 Set 集合
   2. 遍历集合，得到里面的每一个键值对对象
   3. 利用 entry 调用`getKey()` `getValue()`方法获取键和值

3. Lambda 表达式：

   ```java
   map.forEach(new BiConsumer<String, String>() {
       @Overrride
      public void accept(String key, String value){
          System.out.println(key + "=" + value);
      } 
   });
   
   System.out.println("---------------------------");
   
   map.forEach((key. value)-> System.out.println(key + "=" + value));
   ```

底层：forEach 其实就是利用第二种方法进行遍历，依次得到每一个键和值，再调用 accept 方法

#### HashMap

HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。`HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。是利用键计算哈希值，与值无关。

JDK1.8 之前 HashMap 由 **数组+链表** 组成的，也就是 **链表散列**。数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。

**“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

依赖 hashCode 方法和 equals 方法保证键的**唯一**

**ConcurrentHashMap：** 是线程安全的 HashMap。

#### LinkedHashMap

它继承自 `HashMap`，并在 `HashMap` 基础上维护一条双向链表。

由键决定：有序、不重复、无索引

- 支持遍历时会按照插入顺序有序进行迭代。

- 支持按照元素访问顺序排序,适用于封装 LRU（**L**east **R**ecently **U**sed，最近最少使用）缓存工具。

- 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。

#### TreeMap

底层是红黑树结构，由键决定特性：不重复、无索引、可排序（对键进行排序）

#### 可变参数

允许方法形参的个数发生改变；底层是一个数组

**格式：**`类型...参数名`

1. 方法的形参中仅允许写一个可变参数
2. 如果除了可变参数还有其他形参，可变参数要写在最后

#### 集合工具类 Collections (不重要)

### 注意事项

#### 集合判空

《阿里巴巴 Java 开发手册》的描述如下：

> **判断所有集合内部的元素是否为空，使用 `isEmpty()` 方法，而不是 `size()==0` 的方式。**

这是因为 `isEmpty()` 方法的可读性更好，并且时间复杂度为 O(1)。

#### 集合转 Map

《阿里巴巴 Java 开发手册》的描述如下：

> **在使用 `java.util.stream.Collectors` 类的 `toMap()` 方法转为 `Map` 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。**

#### 集合遍历

《阿里巴巴 Java 开发手册》的描述如下：

> **不要在 foreach 循环里进行元素的 `remove/add` 操作。remove 元素请使用 `Iterator` 方式，如果并发操作，需要对 `Iterator` 对象加锁。**

通过反编译你会发现 foreach 语法底层其实还是依赖 `Iterator` 。不过， `remove/add` 操作直接调用的是集合自己的方法，而不是 `Iterator` 的 `remove/add`方法

这就导致 `Iterator` 莫名其妙地发现自己有元素被 `remove/add` ，然后，它就会抛出一个 `ConcurrentModificationException` 来提示用户发生了并发修改异常。这就是单线程状态下产生的 **fail-fast 机制**。

> **fail-fast 机制**：多个线程对 fail-fast 集合进行修改的时候，可能会抛出`ConcurrentModificationException`。 即使是单线程下也有可能会出现这种情况。

Java8 开始，可以使用 `Collection#removeIf()`方法删除满足特定条件的元素

除了上面介绍的直接使用 `Iterator` 进行遍历操作之外，还可以：

- 使用普通的 for 循环
- 使用 fail-safe 的集合类。`java.util`包下面的所有的集合类都是 fail-fast 的，而`java.util.concurrent`包下面的所有的类都是 fail-safe 的。
- ……

#### 集合去重

《阿里巴巴 Java 开发手册》的描述如下：

> **可以利用 `Set` 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 `List` 的 `contains()` 进行遍历去重或者判断包含操作。**

#### 集合转数组

《阿里巴巴 Java 开发手册》的描述如下：

> **使用集合转数组的方法，必须使用集合的 `toArray(T[] array)`，传入的是类型完全一致、长度为 0 的空数组。**

#### 数组转集合

《阿里巴巴 Java 开发手册》的描述如下：

> **使用工具类 `Arrays.asList()` 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 `add/remove/clear` 方法会抛出 `UnsupportedOperationException` 异常。**

### 不可变集合

- 如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践
- 当集合对象被不可信的库调用时，不可变形式是安全的

在List、Set、Map接口中，都存在静态的 of 方法，可以获取一个不可变的集合。这个集合不可添加，不可删除，不可修改

如：`List<String> list = List.of("");`

细节：

- Map 里面的 of 方法，参数是有上限的，最多只能传递20个参数即10个键值对
- 如果键值对的数量超过10个，使用 ofEntries 方法：`Map.ofEntries( hm.entrySet().toArray(new Map.Entry[0]) );`——JDK10以后直接使用 copyOf 方法

#### Stream流

一般会结合Lambda表达式，简化集合、数组的操作

1. 得到一条Stream流，放入数据

   - 单列集合：Collection 中的默认方法 `default Stream<E> stream()`
   - 双列集合：无法直接使用——先通过 keySet() 或 entrySet() 转换成单列集合
   - 数组：Array 工具类中的静态方法 `public static<T> Stream<T> stream(T[] array)`
   - 一堆零散数据：Stream 接口中的静态方法 `public static<T> Stream<T> of(T...values)` `Stream.of(1,2,3,4,5,6).forEach(s->sout(s))`

2. 中间方法

   1. filter() 过滤
   2. limit() 获取前几个元素
   3. skip() 跳过前几个元素
   4. distinct() 元素去重，依赖 hashCode 和 equals 方法
   5. concat() 合并两个流为一个大流
   6. map() 类型转换

   - 中间方法返回新的Stream流，原先的Stream流只能使用一次，建议使用链式编程
   - 修改Stream流中的数据，不会影响原来集合或数组中的数据

3. 终结方法

   1. forEach() 遍历
   2. count() 统计
   3. toArray() 收集流中的数据，放入数组
   4. collect() 收集流中的数据，放入集合——Map 要指定键和值

#### 方法引用

把已有的方法拿来当做函数式接口中抽象方法的方法体用

1. 引用处必须是函数式接口
2. 被引用的方法必须已经存在
3. 被引用方法的形参和返回值需要跟抽象方法保持一致
4. 被引用方法的功能要能满足当前需求

**引用静态方法：**`类名::静态方法`

**引用成员方法：**`对象::成员方法`	1. 其他类：`其他类对象::方法名`  2. 本类：`this::方法名`  3. 父类：`super::方法名`	2.3.的引用处不能是静态方法

**引用构造方法：**`类名::new`

**其他引用方法：**

​	**抽象方法形参**的详解：第一个参数表示被引用方法的调用者，决定可以引用哪些类中的方法，**在 Stream 流中，第一个参数一般都表示流里面的每一个数据**（假设流里面的数据全是字符串，那么使用这种方法进行方法引用只能引用 String 这个类中的方法）；第二个参数到最后一个跟被引用方法的形参保持一致（如果没有第二个参数，说明被引用的方法需要是无参的成员方法）。

- 使用类名引用成员方法：`类名::成员方法`        p.s. 不能引用所有类中的成员方法，与抽象方法的第一个参数(的类)有关
  - 独特规则：被引用方法的形参需要与抽象方法的第二个到最后一个形参保持一致，返回值需保持一致
- 引用数组的构造方法：`数据类型[]::new`        p.s. 数组的类型要和流中数据的类型保持一致

#### Properties 类

Properties 作为 Map集合的操作。可以往 Properties 中添加任意的数据类型，但是一般只往里面添加字符串类型的数据，也不写中文。

与IO流结合的操作的相关特有方法：

`prop.load`：读取

`prop.store`：保存

## IO流

输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。

流的方向：

- 输入流 / 读取  `InputStream`/`Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- 输出流 / 写出  `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

操作文件类型：

- 字节流——所有类型文件
- 字符流——纯文本文件

### 字节输出流 OutputStream

`OutputStream`用于将数据（字节信息）写入到目的地（通常是文件），`java.io.OutputStream`抽象类是所有字节输出流的父类。

`FileOutputStream` 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。

- 参数可以是字符串表示的路径或者File对象
- 创建对象时如果文件不存在会创建一个新的文件，但要保证父级路径存在
- 如果文件已存在，会清空文件
- write方法的参数是整数，实际上写入本地文件中的是该整数在ASCII中对应的字符

类似于 `FileInputStream`，`FileOutputStream` 通常也会配合 `BufferedOutputStream`（字节缓冲输出流，后文会讲到）来使用。

**`DataOutputStream`** 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 `FileOutputStream` 。

`ObjectInputStream` 用于从输入流中读取 Java 对象（`ObjectInputStream`,反序列化），`ObjectOutputStream`将对象写入到输出流(`ObjectOutputStream`，序列化)。

**写出数据**

`void write(int b)` 一次写一个字节数据

`void write(byte[] b)` 一次写一个字节数组数据

`void write(byte[] b, int off, int len)` 一次写一个字节数组的部分数据

**换行**

再写一个换行符 wrap：

- Windows：\r\n	p.s. java对其进行了优化，写其中一个也可以实现换行

- Linux：\n

- Mac：\r

**续写**

FileOutputStream的第二个参数append，默认为false（此时创建对象会清空文件），传递true即可

### 字节输入流 InputStream

用于从源头（通常是文件）读取数据（字节信息）到内存中，`java.io.InputStream`抽象类是所有字节输入流的父类。

`FileInputStream` 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。

- 创建对象如果文件不存在，直接报错
- 一次读一个字节，读出来的是数据在ASCII上对应的数字 `(char)b`
- 读到文件末尾，read方法返回 -1

不过，一般是不会直接单独使用 `FileInputStream` ，通常会配合 `BufferedInputStream`（字节缓冲输入流）来使用。

`DataInputStream` 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 `FileInputStream` 。

`ObjectInputStream` 用于从输入流中读取 Java 对象（反序列化），`ObjectOutputStream` 用于将对象写入到输出流(序列化)。

**循环读取**

循环体内读取 `while((b = fis.read()) != -1){}`

#### 文件拷贝

核心思想：边读边写，循环读写

释放资源规则：先开的流最后关闭

**一次读取一个字节太慢？**

 `public int read(byte[] buffer)` 一次读取一个字节数组数据（数组长度一般为1024的整数倍）

#### IO流中捕获异常

不想手动释放资源？以下方式资源用完最终会自动释放

- JDK7方案

  ```java
  try(创建流对象1; 创建流对象2------ 只允许实现了AutoCloseable的类创建的对象 ){
  
  ​	可能出现异常的代码;
  
  }catch(异常类名 常量名){
  
  ​	异常的处理代码
  
  }
  ```

- JDK9方案

  ```
  创建流对象1;
  创建流对象2;
  try(流1; 流2){
  	可能出现异常的代码;
  }catch(异常类名 变量名){
  	异常的处理代码;
  }
  ```

#### 字符集

- ASCII

- GBK

- Unicode
  - UTF-16
  - UTF-8

**为什么会有乱码？**

1. 读取数据时未读完整个汉字的二进制
2. 编码和解码时的方式不统一

**编码和解码**

### 高级流 ↓

### 字符输入流 Reader

`Reader`用于从源头（通常是文件）读取数据（字符信息）到内存中，`java.io.Reader`抽象类是所有字符输入流的父类。

使用场景：对纯文本文件进行读写操作。 特点：中文不会出现乱码

`InputStreamReader` 是字节流转换为字符流的桥梁，其子类 `FileReader` 是基于该基础上的封装，可以直接操作字符文件。

- 底层也是字节流，按字节进行读取，遇到中文，一次读多个字节，读取后解码，返回一个整数
- 读到文件末尾，read方法返回 -1

### 字符输出流 Writer

`Writer`用于将数据（字符信息）写入到目的地（通常是文件），`java.io.Writer`抽象类是所有字符输出流的父类。

`OutputStreamWriter` 是字符流转换为字节流的桥梁，其子类 `FileWriter` 是基于该基础上的封装，可以直接将字符写入到文件。

- 如上字节输出流

### 字节缓冲流

IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。字节缓冲流这里采用了装饰器模式来增强 `InputStream` 和`OutputStream`子类对象的功能。

字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 `write(int b)` 和 `read()` 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。

#### 字节缓冲输入流 BufferedInputStream

`BufferedInputStream` 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。

`BufferedInputStream` 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 `BufferedInputStream` 源码即可得到这个结论。

#### 字节缓冲输出流 BufferedOutputStream

类似于 `BufferedInputStream` ，`BufferedOutputStream` 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 **8192** 字节。

#### 字符缓冲流

`BufferedReader` （字符缓冲输入流）和 `BufferedWriter`（字符缓冲输出流）类似于 `BufferedInputStream`（字节缓冲输入流）和`BufferedOutputStream`（字节缓冲输出流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。

字符缓冲流对于字符流提升不明显，但是以下两个特有方法是关键

特有方法：

- `readLine()`  读取一行数据，如果没有数据可读了，返回null（一次读一行遇到回车换行结束，但不会把回车换行读取到内存）
- `newLine()`  跨平台通用的换行

### 转换流

是字符流和字节流之间的桥梁——可以根据字符集一次读取多个字节，读取数据不会乱码

- 输入流 `InputStreamReader` 
- 输出流 `OutputStreamWriter` 

作用：

1. 指定字符集读写（JDK11后已淘汰）
2. 字节流想要使用字符流中的方法

### 序列化流

是字节流的子类；是高级流，在创建对象时需要关联基本流。

序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。

- **序列化**：将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

对于 Java 这种面向对象编程语言来说，序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。

- 序列化流 ObjectOutputStream：可以把java中的对象写到本地文件中
- 反序列化流 ObjectInputStream：可以将文件中的对象读取到程序中

#### Serializable接口

**用序列化流将对象写到文件前，需要让Javabean类实现Serialiable接口**，一个类只有实现了Serializable接口，它的对象才能被序列化。

**为什么要序列化对象，什么情况下需要序列化？**

序列化对于面向对象的编程语言来说是非常重要的，因为无论什么编程语言，其底层涉及IO操作的部分还是由操作系统其帮其完成的，而底层IO操作都是以字节流的方式进行的，所以写操作都涉及将编程语言数据类型转换为字节流，而读操作则又涉及将字节流转化为编程语言类型的特定数据类型。

当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化。那为什么还要继承Serializable？那是因为存储对象在存储介质中，以便在下次使用的时候，可以很快捷的重建一个副本。

**序列化后如何修改Javabean类而在反序列化时不报错？**

原因：文件中的版本号跟Javabean类的版本号不匹配

解决：在Javabean类中定义版本号 `private static final long serialVersionUID = 1L;`

**序列化后写到文件中的数据是不能修改的，一旦修改就无法再次读取了**

**transient 关键字：** 不会把修饰的属性序列化到本地文件当中

### 打印流

只有输出流

`System.out` 实际是用于获取一个 `PrintStream` 对象，在虚拟机启动时由虚拟机创建，默认指向控制台；`print`方法实际调用的是 `PrintStream` 对象的 `write` 方法。

`PrintStream` 属于字节打印流，与之对应的是 `PrintWriter` （字符打印流）。`PrintStream` 是 `OutputStream` 的子类，`PrintWriter` 是 `Writer` 的子类。

特点：

- 只操作文件目的地，不操作数据源
- 特有的写出方法，可以实现数据原样写出
- 特有的写出方法，可以实现自动刷新（字节流底层没有缓冲区，开自动刷新与否都一样；字符流想要自动刷新需要开启），自动换行
  - write  跟父类的一样，将指定字节写出
  - println  打印任意数据（原样写出），自动刷新自动换行
  - print  打印任意数据（原样写出），不换行
  - printf  原样写出，带有占位符（如 %s）的打印语句，不换行
- 系统中的标准输出流是不能关闭 `close()` 的，在系统中是唯一的

### 随机访问流

随机访问流指的是支持随意跳转到文件的任意位置进行读写的 `RandomAccessFile` 

### 解 / 压缩流

解压的本质：把压缩包里每一个文件或文件夹读取出来，按层级拷贝到目的地中

ZipInputStream、ZipOutputStream

### 工具包

#### Commons-io

1. 在项目中创建一个文件夹 lib
2. 将commons-io 的 jar 包CV到 lib 文件夹
3. 右击选择 Add as Library 后点击OK
4. 在类中导包使用

**FileUtils 类**

**IOUtils 类**

#### hutool 糊涂包

### IO 设计模式

#### 装饰器模式

**装饰器（Decorator）模式** 可以在不改变原有对象的情况下拓展其功能。

装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。

对于字节流来说， `FilterInputStream` （对应输入流）和`FilterOutputStream`（对应输出流）是装饰器模式的核心，分别用于增强 `InputStream` 和`OutputStream`子类对象的功能。

常见的`BufferedInputStream`(字节缓冲输入流)、`DataInputStream` 等等都是`FilterInputStream` 的子类，`BufferedOutputStream`（字节缓冲输出流）、`DataOutputStream`等等都是`FilterOutputStream`的子类。

举个例子，可以通过 `BufferedInputStream`（字节缓冲输入流）来增强 `FileInputStream` 的功能。

#### 适配器模式

**适配器（Adapter Pattern）模式** 主要用于接口互不兼容的类的协调工作。

适配器模式中存在被适配的对象或者类称为 **适配者(Adaptee)** ，作用于适配者的对象或者类称为**适配器(Adapter)** 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。

IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。

`InputStreamReader` 和 `OutputStreamWriter` 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。`InputStreamReader` 使用 `StreamDecoder` （流解码器）对字节进行解码，**实现字节流到字符流的转换，** `OutputStreamWriter` 使用`StreamEncoder`（流编码器）对字符进行编码，实现字符流到字节流的转换。

`InputStream` 和 `OutputStream` 的子类是被适配者， `InputStreamReader` 和 `OutputStreamWriter`是适配器。

#### 工厂模式

工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 `Files` 类的 `newInputStream` 方法用于创建 `InputStream` 对象（静态工厂）、 `Paths` 类的 `get` 方法创建 `Path` 对象（静态工厂）、`ZipFileSystem` 类（`sun.nio`包下的类，属于 `java.nio` 相关的一些内部实现）的 `getPath` 的方法创建 `Path` 对象（简单工厂）。

#### 观察者模式

NIO 中的文件目录监听服务使用到了观察者模式。

NIO 中的文件目录监听服务基于 `WatchService` 接口和 `Watchable` 接口。`WatchService` 属于观察者，`Watchable` 属于被观察者。

### IO 模型

**从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。**

**从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。**

当应用程序发起 I/O 调用后，会经历两个步骤：

1. 内核等待 I/O 设备准备好数据
2. 内核将数据从内核空间拷贝到用户空间。

UNIX 系统下， IO 模型一共有 5 种：**同步阻塞 I/O**、**同步非阻塞 I/O**、**I/O 多路复用**、**信号驱动 I/O** 和**异步 I/O**。

#### BIO (Blocking I/O)

**BIO 属于同步阻塞 IO 模型** 。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。

在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

#### NIO (Non-blocking/New I/O)

Java 中的 NIO 于 Java 1.4 中引入，对应 `java.nio` 包，提供了 `Channel` , `Selector`，`Buffer` 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。

Java 中的 NIO 可以看作是 **I/O 多路复用模型**。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。

**核心组件**

- **Buffer（缓冲区）**：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。

- **Channel（通道）**：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。

- **Selector（选择器）**：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。

#### AIO (Asynchronous I/O)

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

## 多线程

**Java 线程和操作系统的线程有啥区别？**

现在的 Java 线程的本质其实就是操作系统的线程。

线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：

1. 一对一（一个用户线程对应一个内核线程）
2. 多对一（多个用户线程映射到一个内核线程）
3. 多对多（多个用户线程映射到多个内核线程）

在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。Solaris 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持多对多和一对一。

**并发与并行的区别**

- **并发**：两个及两个以上的作业在同一 **时间段** 内执行。
- **并行**：两个及两个以上的作业在同一 **时刻** 执行。

​	最关键的点是：是否是 **同时** 执行。

**同步和异步的区别**

- **同步**：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
- **异步**：调用在发出之后，不用等待返回结果，该调用直接返回。

### 实现方式

1. 继承Thread类->重写run方法->创建子类对象->start方法启动线程
2. 实现Runnable接口->重写run方法->创建实现类对象->创建Thread类的对象并开启线程
3. 实现Callable接口（可以获取多线程运行的结果）->重写call方法（有返回值）->创建实现类对象->创建Future接口的实现类FutureTask的对象（用于管理多线程运行的结果）->创建Thread类的对象并开启线程并`ft.get()`获取结果
4. 使用`ExecutorService`线程池……使用`CompletableFuture`类、基于`ThreadGroup`线程组、使用`FutureTask`类、使用匿名内部类或`Lambda`表达式、使用`Timer`定时器类、使用`ForkJoin`线程池或`Stream`并行流

不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。严格来说，Java 就只有一种方式可以创建线程，那就是通过`new Thread().start()`创建。不管是哪种方式，最终还是依赖于`new Thread().start()`。

*不知道从何时起，`Java`并发编程的八股文，在“`Java`有几种创建线程的方式”这道题上，开始以“数量”为荣，写的越多，显得越专业。那这真的对吗？可以说对，但严格意义上来说，又不对。究根结底，这个错误观念的源头，来自于《`Java`编程思想》（《`Thinking In Java`》）和《`Java`核心技术》（《`Core Java`》）这两本书。*

既然实现`Runnable、Callable`接口，不是创建线程的方式，那它们究竟是什么？准确来说，这是两种创建“线程体”的方式，包括继承`Thread`类重写`run()`方法也是。那**线程体**是什么？线程是一个独立的执行单元，可以被操作系统调度；而线程体仅仅只是一个任务，就类似于一段普通的代码，需要线程作为载体才能运行，**线程是执行线程体的容器，线程体是一个可运行的任务**。另外，不管是哪种创建线程体的方式，到最后都是依赖于`Runnable`这个类实现的。

### 常见成员方法

`getName()`  返回线程的名称

`setName()`  设置线程的名称（构造方法也可以设置名称）

`static Thread currentThread()`  获取当前线程的对象

`static void sleep(long time)`  让线程休眠，单位为毫秒

#### 线程优先级

`setPriority()`  设置线程的优先级

`final int getPriority()`  获取线程的优先级

线程优先级的范围为**1~10**，默认为**5**

#### 守护线程

`final void setDaemon(true)`

只要其他的非守护线程执行完毕，即使守护线程的代码没有执行完，也会陆续结束。

#### 礼让线程

`public static void yield()`

出让当前CPU的执行权

#### 插入线程

`public static void join(空参 || long n)`

等待调用 join 方法的线程运行结束(，最多等待n毫秒) (亦为插入到当前线程之前)

#### interrupt 方法

用于打断 sleep，wait，join 的线程。可以用来打断处于阻塞、运行状态的线程。

- 打断正在睡眠的线程，会清空打断状态，如 sleep
- 打断正常运行的线程，不会清空打断状态 (即打断标记 `isInterrupted()` )

可以打断 park() 状态的线程：打断标记为真时 park 方法不会被调用——需调用`Interrupted()`而非`isInterrupted()`

#### 不推荐的方法

这些方法已过时，容易破坏同步代码块，导致线程死锁

`stop()`  停止线程运行

`suspend()`  挂起（暂停）线程运行

`resume()`  恢复线程运行

### 两阶段终止模式

在一个线程T1中如何“优雅”地终止线程T2？这里的“优雅”指的是给T2一个料理后事的机会。

![两阶段终止模式](D:\.StudyWork\CodeBase\笔记\Java\图片\两阶段终止模式.png)

#### 错误思路

1. 使用线程对象的 stop 方法停止线程
   - stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁

2. 使用 System.exit(int) 方法停止线程
   - 目的仅是停止一个线程，而这种做法会让整个程序都停止

### 线程的生命周期和状态

- NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。仅是在语言层面创建了线程对象，还未与操作系统线程关联。

- RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。获取了CPU时间片运行中的状态。

  - 当CPU时间片用完，会从运行状态转换至可运行状态，会导致线程的上下文切换。

  / 可运行状态 (就绪状态)，指该线程已经被创建 (与操作系统线程关联)，可以由CPU调度执行。

- BLOCKED：阻塞状态，需要等待锁释放。

  - 如果调用了阻塞API，如 BIO 读写文件，这时该线程实际不会用到CPU，会导致线程上下文切换，进入阻塞状态

  - 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至可运行状态

  - 与可运行状态的区别是，对阻塞状态的线程来说只要它们一直不被唤醒，调度器就一直不会考虑调度它们

- *WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作 (通知或中断) 。

- *TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。

- TERMINATED：终止状态，表示该线程已经运行完毕，生命周期已经结束，不会再转为其它状态。

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。

- 线程创建之后它将处于 **NEW（新建）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。
- 当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。
- **TIMED_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。
- 当线程进入 `synchronized` 方法/块或者调用 `wait` 后（被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态。
- 线程在执行完了 `run()`方法之后将会进入到 **TERMINATED（终止）** 状态。

#### 线程上下文切换

线程在执行过程中会有自己的运行条件和状态（也称上下文）。当出现如下情况的时候，线程会从占用 CPU 状态中退出。

- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。

- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。

- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。

- 被终止或结束运行

这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 **上下文切换**。

上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。

#### 可以直接调用 Thread 类的 run 方法吗？

new 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。**简而言之：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

#### sleep 方法与 yield 方法的区别

**sleep**：

- 调用 sleep 会让当前线程从 *Running* 进入 *Timed Waiting* 状态
- 其它线程可以使用 interrupt 方法**打断**正在睡眠的线程，这时 sleep 方法会抛出 `InterruptedException`
- 睡眠结束后的线程未必会立刻得到执行
- 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性

在没有利用cpu来计算时，不要让`while(true)`空转浪费cpu，这时可以使用 yield 或 sleep 来让出cpu的使用权给其它程序。可以用 wait 或条件变量达到类似的效果，不同的是后两种方法都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景，而 sleep 适用于无需锁同步的场景。

**yield**：

- 调用 yield 会让当前线程从 *Running* 进入 *Runnable* 状态，然后调度执行其它同优先级的线程，如果这时没有同优先级的线程，那么不能保证让当前线程暂停的效果
- 具体的实现依赖于操作系统的任务调度器

#### Thread#sleep() 方法和 Object#wait() 方法对比

**共同点**：两者都可以暂停线程的执行

**区别**：

- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

**为什么 `wait()` 方法不定义在 `Thread` 中？**

`wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。

**为什么 `sleep()` 方法定义在 `Thread` 中？**

因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

### 线程安全问题

**临界区 Critical Section**

- 一个程序运行多个线程本身是没有问题的
- 问题出在多个线程访问**共享资源**
  - 多个线程读共享资源其实也没什么问题
  - 在多个线程对共享资源读写操作时发生指令交错，就会出现问题
- 一段代码块内如果存在对**共享资源**的多线程读写操作，称这段代码块为**临界区**

**竞态条件 Race Condition**

多个线程在临界区内执行，由于代码的**执行序列不同**而导致结果无法预测，称之为发生了**竞态条件**

#### synchronized 关键字

`synchronized` 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁；

- `synchronized` 关键字加到实例方法上是给对象实例上锁；

- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能。

#### 同步代码块

线程执行时，有随机性。——同步代码块：把操作共享数据的代码锁起来：`synchronized (锁对象) {}`

特点：

- 锁默认打开，有一个线程进去了，锁自动关闭
- 锁中的代码全部执行完毕，线程出来，锁自动打开
- 当创建多个 Thread 对象时，锁对象必须是唯一的（包括lock锁），用static修饰
- 锁对象可以写——类名.class 作为对象

#### 同步方法

synchronized 关键字修饰方法：`修饰符 synchronized 返回值类型 方法名(参数) {}`

特点：

- 同步方法是锁住方法里所有的代码
- 锁对象不能自己指定
  1. 非静态：this
  2. 静态：当前类的字节码文件对象

![同步方法](D:\.StudyWork\CodeBase\笔记\Java\图片\同步方法.png)

书写技巧：先写同步代码块，再把里面的代码抽取成方法

构造方法不能使用 synchronized 关键字修饰。不过，可以在构造方法内部使用 synchronized 代码块。

#### Lock 锁

Lock实现提供比使用synchronized方法和语句可获得的更广泛的锁定操作

`void lock() 获得锁	void unlock() 释放锁` 手动上下锁。Lock是接口不能直接实例化，采用它的实现类ReentrantLock来实例化

**构造方法：**`ReentrantLock()`  空参构造创建一个ReentrantLock的实例

`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承 AQS（`AbstractQueuedSynchronizer`），添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。

- **公平锁** : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。

- **非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。

**注**：将lock锁的代码写在 try-catch-finally 中，unlock() 写在其中的 finally 中

#### ReentrantLock

`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承 AQS（`AbstractQueuedSynchronizer`），添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。

#### synchronized 和 ReentrantLock 有什么区别？

- 两者都是可重入锁
  - **可重入锁** 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。（JDK 提供的所有现成的 `Lock` 实现类，包括 `synchronized` 关键字锁都是可重入的。）
- synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API
- ReentrantLock 比 synchronized 增加了一些高级功能，主要来说主要有三点：
  - **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说当前线程在等待获取锁的过程中，如果其他线程中断当前线程「 `interrupt()` 」，当前线程就会抛出 `InterruptedException` 异常，可以捕捉该异常进行相应处理。
  - **可实现公平锁** : `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来指定是否是公平的。
  - **可实现选择性通知（锁可以绑定多个条件）**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法。
  - **支持超时** ：`ReentrantLock` 提供了 `tryLock(timeout)` 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待。

**可中断锁和不可中断锁的区别**

- **可中断锁**：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。`ReentrantLock` 就属于是可中断锁。
- **不可中断锁**：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 就属于是不可中断锁。

**共享锁和独占锁的区别**

- **共享锁**：一把锁可以被多个线程同时获得。
- **独占锁**：一把锁只能被一个线程获得。

#### synchronized 和 volatile 有什么区别？

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- `volatile` 关键字是线程同步的轻量级实现，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 。
- `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。
- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。

#### 线程持有读锁还能获取写锁吗？

- 在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。
- 在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。

#### 读锁为什么不能升级为写锁？

写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。

另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。

### 死锁

线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

产生死锁的四个必要条件：

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系。

#### 如何检测死锁？

- 使用`jmap`、`jstack`等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:`的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用`top`、`df`、`free`等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。

- 采用 VisualVM、JConsole 等工具进行排查。

#### 如何预防和避免线程死锁?

**如何预防死锁？** 破坏死锁的产生的必要条件即可：

1. **破坏请求与保持条件**：一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

**如何避免死锁？**

避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

**安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。

#### 等待唤醒机制（生产者和消费者）

生产者和消费者线程交替执行

**消费者等待**

消费者先抢到执行权，但桌子上没有食物

1. **消费者**判断桌子上是否有食物
2. 如果没有就等待 `wait()`
3. **生产者**制作食物
4. 把食物放在桌子上
5. 叫醒 `notify()` 等待的消费者来吃

**生产者等待**

生产者生产完食物后，又抢到执行权

1. **生产者**判断桌子上是否有食物
2. 有则等待，没有则制作食物
3. 把食物放在桌子上
4. 叫醒等待的消费者来吃
5. **消费者**判断桌子上是否有食物
6. 如果没有就等待 `wait()`
7. 如果有就开吃
8. 吃完后唤醒生产者继续生产

#### 等待唤醒机制（阻塞队列方式）

put 数据时，放不进去会等着，叫阻塞；take 数据时，取不出来会等着，也叫阻塞。

**继承结构：** (接口) Iterable、Collection、Queue、BlockingQueue —实现类> ArrayBlockingQueue (底层是数组，有界)、LinkedBlockingQueue (底层是链表，无界但不是真正的无界，最大为int的最大值)

#### 多线程间的比较

把**线程运行的结果（Callable，有返回值）**进行比较

### 线程池

**核心原理**：提交任务时，池会创建新的线程对象，任务执行完毕，线程归还给池，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可。

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

**线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。**

#### Executor 框架

`Executor` 框架是 Java5 之后引进的，在 Java 5 之后，通过 `Executor` 来启动线程比使用 `Thread` 的 `start` 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。

this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。

`Executor` 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，`Executor` 框架让并发编程变得更加简单。

主要由三大部分组成：

1. **任务(`Runnable` /`Callable`)**
2. **任务的执行(`Executor`)**
3. **异步计算的结果(`Future`)**

**线程池创建的两种方式**

1. **通过`ThreadPoolExecutor`构造函数来创建（推荐）**

2. **通过 `Executor` 框架的工具类 `Executors` 来创建**

   - Executors：线程池的工具类通过调用方法返回不同类型的线程池对象
     - `public static ExecutorService newCachedThreadPool()`  创建一个没有上限的线程
     - `public static ExecutorService newFixedThreadPool(int nThreads)`  创建有上限的线程池

   - `FixedThreadPool`：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
   - `SingleThreadExecutor`： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
   - `CachedThreadPool`： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。
   - `ScheduledThreadPool`：给定的延迟后运行任务或者定期执行任务的线程池。

#### 自定义线程池

线程池实现类 `ThreadPoolExecutor` 是 `Executor` 框架最核心的类。

`ThreadPoolExecutor pool = new ThreadPoolExecutor(., ., ., ., ., ., .)`

核心线程不会销毁，临时线程会被销毁

参数 (按顺序)：

1. 核心线程数（不能小于0）
2. 线程池中最大线程的数量（不能小于0，最大 >= 核心）
3. 临时线程的空闲时间（值）
4. 临时线程的空闲时间（时间单位）（用 TimeUnit 指定）
5. 阻塞队列（不能为null）
6. 创建线程的方式（不能为null）——`Executors.defaultThreadFactory()`
7. 执行的任务过多时的解决方案——拒绝策略：（不能为null）
   1.  `new ThreadPoolExecutor.AbortPolicy`默认：丢弃任务并抛出异常
   2. `new ThreadPoolExecutor.DiscardPolicy`：丢弃任务，但不抛出异常，不推荐
   3. `new ThreadPoolExecutor.DiscardOldestPolicy`：抛弃队列中等待最久的任务，然后把当前任务加入队列
   4. `new ThreadPoolExecutor.CallerRunsPolicy`：调用任务的 run() 方法绕过线程池直接执行

`ThreadPoolExecutor` 3 个最重要的参数：

- `corePoolSize` : 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- `maximumPoolSize` : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- `workQueue` : 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

`ThreadPoolExecutor`其他常见参数 :

- `keepAliveTime`:当线程池中的线程数量大于 `corePoolSize` ，即有非核心线程（线程池中核心线程以外的线程）时，这些非核心线程空闲后不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁。
- `unit` : `keepAliveTime` 参数的时间单位。
- `threadFactory` :executor 创建新线程的时候会用到。
- `handler` : 拒绝策略

#### 动态修改线程池的参数

思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：

- **`corePoolSize` :** 核心线程数线程数定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

它们基本决定了线程池对于任务的处理策略。

……

#### 线程池常用的阻塞队列总结

新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

#### 如何给线程池命名？

初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。

默认情况下创建的线程名字类似 `pool-1-thread-n` 这样的，没有业务含义，不利于我们定位问题。

给线程池里的线程命名通常有下面两种方式：

1. **利用 guava 的 `ThreadFactoryBuilder`**
2. **自己实现 `ThreadFactory`。**

#### 线程池多大合适？

**最大并行数：** `Runtime.getRuntime().availableProcesors()` 返回可用处理器的数目

- CPU 密集型运算：最大并行数 + 1
- I/O 密集型运算：最大并行数 * 期望CPU利用率 * 总时间（CPU计算时间+等待时间） / CPU计算时间

#### 为什么不推荐使用内置线程池？

在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。

使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 `Executors` 去创建，而是通过 `ThreadPoolExecutor` 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

#### 线程池处理任务的流程了解吗？

1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。
2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。
3. 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。
4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用`RejectedExecutionHandler.rejectedExecution()`方法。

**线程池在提交任务前，可以提前创建线程吗？**

答案是可以的！`ThreadPoolExecutor` 提供了两个方法帮助我们在提交任务之前，完成核心线程的创建，从而实现线程池预热的效果：

- `prestartCoreThread()`:启动一个线程，等待任务，如果已达到核心线程数，这个方法返回 false，否则返回 true；
- `prestartAllCoreThreads()`:启动所有的核心线程，并返回启动成功的核心线程数。

### volatile 关键字

`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。`volatile` 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 `volatile` 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

#### 如何禁止指令重排序？

**在 Java 中，`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。** 如果我们将变量声明为 **`volatile`** ，在对这个变量进行读写操作的时候，会通过插入特定的 **内存屏障** 的方式来禁止指令重排序。

在 Java 中，`Unsafe` 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：

```
public native void loadFence();
public native void storeFence();
public native void fullFence();
```

理论上来说，通过这个三个方法也可以实现和`volatile`禁止重排序一样的效果，只是会麻烦一些。

#### volatile 可以保证原子性么？

**`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性**。`synchronized` 关键字两者都能保证。

其实，如果想要保证代码运行正确也非常简单，利用 `synchronized`、`Lock (ReentrantLock)`或者`AtomicInteger`都可以。

### JMM (Java 内存模型)

JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。

要想理解透彻 JMM（Java 内存模型），先要从 **CPU 缓存模型和指令重排序** 说起！

#### 为什么要弄一个 CPU 高速缓存呢？

类比开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 **CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。**甚至可以把 **内存看作外存的高速缓存。**总结：**CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。**

**CPU Cache 的工作方式：** 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 **内存缓存不一致性的问题** ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 i++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。**CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 [MESI 协议](https://zh.wikipedia.org/wiki/MESI协议)）或者其他手段来解决。** 这个缓存一致性协议指的是在 CPU 高速缓存与主内存交互的时候需要遵守的原则和规范。不同的 CPU 中，使用的缓存一致性协议通常也会有所不同。

程序运行在操作系统之上，操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，操作系统也就同样需要解决内存缓存不一致性问题。操作系统通过 **内存模型（Memory Model）** 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。

#### 什么是指令重排序？

简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。常见的指令重排序有下面 2 种情况：

- **编译器优化重排**：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。
- **指令并行重排**：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。Java 源代码会经历 **编译器优化重排 —> 指令并行重排 —> 内存系统重排** 的过程，最终才变成操作系统可执行的指令序列。**指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致** ，所以在多线程下，指令重排序可能会导致一些问题。

对于编译器优化重排和处理器的指令重排序（指令并行重排和内存系统重排都属于是处理器级别的指令重排序），处理该问题的方式不一样。

- 对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。
- 对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。
  - 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它会在处理器写入值时，强制将写缓冲区中的数据刷新到主内存；在读取值之前，使处理器本地缓存中的相关数据失效，强制从主内存中加载最新值，从而保障变量的可见性。

#### JMM (Java Memory Model)

### 乐观锁和悲观锁

**悲观锁**总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。

像 Java 中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。

**乐观锁**总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。

不过，大量失败重试的问题也是可以解决的，像 `LongAdder`以空间换时间的方式就解决了这个问题。在 Java 中`java.util.concurrent.atomic`包下面的原子变量类（比如`AtomicInteger`、`LongAdder`）就是使用了乐观锁的一种实现方式 **CAS** 实现的。

理论上来说：

- 悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如`LongAdder`），也是可以考虑使用乐观锁的，要视实际情况而定。
- 乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考`java.util.concurrent.atomic`包下面的原子变量类）。



乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。

#### 版本号机制

一般是在数据表中加上一个数据版本号 `version` 字段，表示数据被修改的次数。当数据被修改时，`version` 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 `version` 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 `version` 值相等时才更新，否则重试更新操作，直到更新成功。

#### CAS

CAS 的全称是 **Compare And Swap（比较与交换）** ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。

CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。**原子操作** 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。

CAS 涉及到三个操作数：

- **V**：要更新的变量值(Var)
- **E**：预期值(Expected)
- **N**：拟写入的新值(New)

当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。

**Java 中 CAS 是如何实现的**

Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。在 Java 中，实现 CAS（Compare-And-Swap, 比较并交换）操作的一个关键类是`Unsafe`。`sun.misc`包下的`Unsafe`类提供了`compareAndSwapObject`、`compareAndSwapInt`、`compareAndSwapLong`方法来实现的对`Object`、`int`、`long`类型的 CAS 操作。

`Unsafe`类位于`sun.misc`包下，是一个提供低级别、不安全操作的类。由于其强大的功能和潜在的危险性，它通常用于 JVM 内部或一些需要极高性能和底层访问的库中，而不推荐普通开发者在应用程序中使用。

**CAS 算法存在的问题**

- ABA 问题是 CAS 算法最常见的问题——如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 **"ABA"问题。**
- 循环时间长开销大
- 只能保证一个共享变量的原子操作

### StampedLock

`StampedLock` 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 `Condition`。

### 原子类

Atomic 原子类，所谓原子类说简单点就是具有原子/原子操作特征的类。`java.util.concurrent.atomic` 包中的 `Atomic` 原子类提供了一种线程安全的方式来操作单个变量。`Atomic` 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 `synchronized` 块或 `ReentrantLock`）。

根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类：

1. 使用原子的方式更新**基本类型**

   - `AtomicInteger`：整型原子类

   - `AtomicLong`：长整型原子类

   - `AtomicBoolean`：布尔型原子类


2. 使用原子的方式更新**数组**里的某个元素

   - `AtomicIntegerArray`：整型数组原子类

   - `AtomicLongArray`：长整型数组原子类

   - `AtomicReferenceArray`：引用类型数组原子类


3. **引用类型**

   - `AtomicReference`：引用类型原子类

   - `AtomicMarkableReference`：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来

   - `AtomicStampedReference`：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。


4. **对象的属性修改类型**

   - `AtomicIntegerFieldUpdater`:原子更新整型字段的更新器

   - `AtomicLongFieldUpdater`：原子更新长整型字段的更新器

   - `AtomicReferenceFieldUpdater`：原子更新引用类型里的字段


#### 原子性

线程安全问题表现为三个方面： **原子性、可见性、有序性**。**原子性（Atomic**）就是不可分割的意思，是指在进行一系列操作的时候这些操作要么全部执行要么全部不执行，不存在只执行一部分的情况。

### 常见并发容器

- **`ConcurrentHashMap`** : 线程安全的 `HashMap`

- **`CopyOnWriteArrayList`** : 线程安全的 `List`，在读多写少的场合性能非常好，远远好于 `Vector`。

- **`ConcurrentLinkedQueue`** : 高效的并发队列，使用链表实现。可以看做一个线程安全的 `LinkedList`，这是一个非阻塞队列。

- **`BlockingQueue`** : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。

- **`ConcurrentSkipListMap`** : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。

### ThreadLocal

通常情况下，创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？**

JDK 中自带的`ThreadLocal`类正是为了解决这样的问题。 **`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

对于`ThreadLocal`，第一反应可能是很简单呀，线程的变量副本，每个线程隔离。那这里有几个问题可以思考一下：

- `ThreadLocal`的 key 是**弱引用**，那么在 `ThreadLocal.get()`的时候，发生**GC**之后，key 是否为**null**？
- `ThreadLocal`中`ThreadLocalMap`的**数据结构**？
- `ThreadLocalMap`的**Hash 算法**？
- `ThreadLocalMap`中**Hash 冲突**如何解决？
- `ThreadLocalMap`的**扩容机制**？
- `ThreadLocalMap`中**过期 key 的清理机制**？**探测式清理**和**启发式清理**流程？
- `ThreadLocalMap.set()`方法实现原理？
- `ThreadLocalMap.get()`方法实现原理？
- 项目中`ThreadLocal`使用情况？遇到的坑？
- ……

### Future 类

`Future` 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 `Future` 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。

这其实就是多线程中经典的 **Future 模式**，可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。

在 Java 中，`Future` 类只是一个泛型接口，位于 `java.util.concurrent` 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：

- 取消任务；
- 判断任务是否被取消;
- 判断任务是否已经执行完成;
- 获取任务执行结果。

#### Callable 和 Future 有什么关系？

可以通过 `FutureTask` 来理解 `Callable` 和 `Future` 之间的关系。

`FutureTask` 提供了 `Future` 接口的基本实现，常用来封装 `Callable` 和 `Runnable`，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。`ExecutorService.submit()` 方法返回的其实就是 `Future` 的实现类 `FutureTask` 。

#### CompletableFuture 类

实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，这种场景还是挺常见的。如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 **无前后顺序关联** 的，可以 **并行执行** ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。

`Future` 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 `get()` 方法为阻塞调用。Java 8 才被引入`CompletableFuture` 类可以解决`Future` 的这些缺陷。`CompletableFuture` 除了提供了更为好用和强大的 `Future` 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。

### AQS

AQS 的全称为 `AbstractQueuedSynchronizer` ，翻译过来的意思就是抽象队列同步器。这个类在 `java.util.concurrent.locks` 包下面。AQS 就是一个抽象类，主要用来构建锁和同步器。因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如 `ReentrantLock`，`Semaphore`，其他的诸如 `ReentrantReadWriteLock`，`SynchronousQueue`等等皆是基于 AQS 的。

#### AQS 原理

#### AQS 核心思想

### 虚拟线程

## 反射

反射赋予了我们在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性，即允许对成员变量，成员方法和构造方法的信息进行编程访问。

平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是，这并不代表反射没有用。相反，正是因为反射，我们才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。*IDEA的自动提示也就是用反射实现的。*

**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。**另外，像 Java 中的一大利器 **注解** 的实现也用到了反射。

## 注解

`Annotation` （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。

注解本质是一个继承了`Annotation` 的特殊接口，JDK 提供了很多内置的注解（比如 `@Override`、`@Deprecated`），同时，我们还可以自定义注解。

主要的作用有以下四方面：

- 生成文档，通过代码里标识的元数据生成javadoc文档。
- 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。
- 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。
- 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。

注解的常见分类：

- **Java自带的标准注解**，包括`@Override`、`@Deprecated`和`@SuppressWarnings`，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。

- **元注解**，元注解是用于定义注解的注解，包括`@Retention`、`@Target`、`@Inherited`、`@Documented`，`@Retention`用于标明注解被保留的阶段，`@Target`用于标明注解使用的范围，`@Inherited`用于标明注解可继承，`@Documented`用于标明是否生成javadoc文档。

- **自定义注解**，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。

### Java内置注解

- `@Override`：表示当前的方法定义将覆盖父类中的方法

- `@Deprecated`：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告

- `@SuppressWarnings`：表示关闭编译器警告信息

### 元注解

- @Tatget：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 
- @Retention & @RetentionTarget：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）
- @Documented：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息
- @Inherited：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解
- @Repeatable
- @Native

### 自定义注解

## 代理模式

代理模式是一种比较好理解的设计模式。简单来说就是 **我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能（通过接口）。**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。**

### 静态代理

**静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类）。** 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

从 JVM 层面来说， **静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**

### 动态代理

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( *CGLIB 动态代理机制*)。

从 JVM 角度来说，**动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**

说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。**动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。**

## JVM

### 类文件结构

根据 Java 虚拟机规范，Class 文件通过 `ClassFile` 定义，有点类似 C 语言的结构体。

#### 魔数 (Magic Number)

每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是**确定这个文件是否为一个能被虚拟机接收的 Class 文件**。Java 规范规定魔数为固定值：0xCAFEBABE。如果读取的文件不是以这个魔数开头，Java 虚拟机将拒绝加载它。

### 类加载过程

#### 类的生命周期

类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。

#### 类加载过程

**Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？**

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。

#### 类卸载

**卸载类即该类的 Class 对象被 GC。**

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被 GC

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，JDK 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

### JVM参数

#### 堆内存

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

#### 垃圾收集相关

**垃圾回收器**

为了提高应用程序的稳定性，选择正确的**垃圾收集算法**至关重要。

JVM 具有四种类型的 GC 实现：

- 串行垃圾收集器
- 并行垃圾收集器
- CMS 垃圾收集器
- G1 垃圾收集器

#### 处理 OOM

对于大型应用程序来说，面对内存不足错误是非常常见的，这反过来会导致应用程序崩溃。这是一个非常关键的场景，很难通过复制来解决这个问题。

### JDK 命令行工具

这些命令在 JDK 安装目录下的 bin 目录下：

- **`jps`** (JVM Process Status）: 类似 UNIX 的 `ps` 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；

- **`jstat`**（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;

- **`jinfo`** (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;

- **`jmap`** (Memory Map for Java) : 生成堆转储快照;

- **`jhat`** (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。JDK9 移除了 jhat；

- **`jstack`** (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。

## 网络编程

在网络通信协议下，不同计算机上运行的程序进行的数据传输

- Java中可以使用 java.net 包下的技术轻松开发出常见的网络应用程序

**软件架构**有：B/S 、C/S

### 三要素

#### IP

设备在网络中的地址，是唯一的标识

**InetAddress类**

- `getByName(String host)` 在给定主机名的情况下确定主机的 IP 地址，主机名可以是机器名称，也可以是 IP 地址
- `getHostName()` 获取此 IP 地址的主机名
- `getHostAddress()` 返回文本显示中的 IP 地址字符串

#### 端口号

应用程序在设备中唯一的标识

#### 协议

数据在网络中传输的规则

OSI参考模型：单模型过于理想化，未能在互联网上进行广泛推广

TCP/IP参考模型（TCP/IP协议）：事实上的国际标准

### UDP 协议

#### 发送数据

1. 创建发送端的 DatagramSocket 对象
   - 绑定端口，以后就是通过该端口向外发送
   - 空参：所有可用的端口重随机使用一个
   - 有参：指定端口号进行绑定
2. 数据打包  DatagramPacket 类
3. 发送数据 ` ds.send()`
4. 释放资源  `ds.close()`

#### 接收数据

1. 创建接收端的 DatagramSocket 对象
   - 在接收时，一定要绑定端口，且一定与发送端的保持一致
2. 接收打包好的数据  DatagramPacket 类与 `ds.receive(dp)`（receive方法是阻塞的）
3. 解析数据包  `dp.get...()`
4. 释放资源

### TCP协议

TCP 通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象，通过Socket产生IO流进行网络通信

通信之前要保证连接已建立！

#### 发送和接收数据

**客户端**  输出流

1. 创建客户端的 Socket 对象与指定服务器连接——三次握手协议保证连接建立
2. 获取输出流 `getOutputStream`，写数据
3. 释放资源

**服务器**  输入流

1. 创建服务器端的 Socket 对象 `ServerSocket`
2. 监听客户端连接 `accept`，返回一个Socket对象
3. 获取输入流 `getInputStream`，读数据，并把数据显示在控制台
4. 释放资源

#### 三次握手

确保连接建立

#### 四次挥手

确保连接断开，且数据处理完毕

## Java 新特性

见面试八股文...

### Java 8

Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。

### Java 17

Java 17 将是继 Java 8 以来最重要的长期支持（LTS）版本，是 Java 社区八年努力的成果。Spring 6.x 和 Spring Boot 3.x 最低支持的就是 Java 17。

### Java 21

JDK 21 于 2023 年 9 月 19 日 发布，这是一个非常重要的版本，里程碑式。JDK21 是 LTS（长期支持版），至此为止，目前有 JDK8、JDK11、JDK17 和 JDK21 这四个长期支持版了。

