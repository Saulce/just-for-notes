# 算法之数组

**数组是存放在连续内存空间上的相同类型数据的集合。**

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

正是**因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。** **数组的元素是不能删的，只能覆盖。**

### 那么二维数组在内存的空间地址是连续的么？

在C++中二维数组在地址空间上是连续的。

Java的二维数组可能是如下排列的方式：

![](D:\.StudyWork\CodeBase\笔记\数据结构与算法\图片\Java二维数组排列.png)

## 回文数

1. 将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。
2. 通过取整和取余操作获取整数中对应的数字进行比较。
3. *将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。（但是，如果反转后的数字大于 int.MAX 我们将遇到整数溢出问题，为了避免数字反转可能导致的溢出问题，只反转数字的一半）

## 二分查找

**有序数组** **无重复元素**

**循环不变量原则：**

左闭右闭写法：[ , ]

循环不变量： `while(l <= r){ … r = middle - 1; … }`

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

左闭右开写法：[ , )

循环不变量：`while(l < r){ … r = middle; … }`

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

例题：

1. 平方根问题
2. 数组搜索给定值

## 移除元素

很明显暴力解法的时间复杂度是O(n^2)

// 双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

**双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。**

// 相向双指针法：会改变顺序

## 有序数组的平方

暴力解法 (×)  双指针法 (√)

数组其实是有序的， 只不过负数平方之后可能成为最大数了。

那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];` 。

如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];` 。

## 长度最小的子数组

数组操作中另一个重要的方法：**滑动窗口**。所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

如果只用一个for循环来表示滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入暴力解法的怪圈。所以只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。

可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

主要确定：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

```java
while (sum >= s) {
                result = Math.min(result, j - i + 1);  // 取子序列的长度并比较
                sum -= nums[i++];  // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
```

**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

**会疑惑为什么时间复杂度是O(n)?**  

不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。

## 螺旋矩阵II

求解本题依然是要坚持循环不变量原则。

模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察对代码的掌控能力。

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是**一进循环深似海，从此offer是路人**。

一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开的原则，这样这一圈才能按照统一的规则画下来。做这道题目之所以一直写不好，代码越写越乱，就是因为在画每一条边的时候，一会左开右闭，一会左闭右闭，一会又来左闭右开，岂能不乱。相信遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实**真正解决题目的代码都是简洁的，或者有原则性的。**

## 区间和

前缀和；顺便练习一下ACM输入输出模式（笔试面试必备）

前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。**前缀和 在涉及计算区间和的问题时非常有用**！

例如，要统计 `vec[i]` 这个数组上的区间和。先做累加，即 `p[i]` 表示 下标 0 到 i 的 `vec[i]` 累加 之和。如果想统计在vec数组上 下标 2 到下标 5 之间的累加和，那就用 `p[5] - p[1` 就可以了。

```
p[1] = vec[0] + vec[1];
p[5] = vec[0] + vec[1] + vec[2] + vec[3] + vec[4] + vec[5];
p[5] - p[1] = vec[2] + vec[3] + vec[4] + vec[5];
```

p 数组是之前就计算好的累加和，所以后面每次求区间和的之后只需要 O(1) 的操作。

**注**： 在使用前缀和求解的时候，要特别注意 求解区间。如上，如果要求 区间下标 [2, 5] 的区间和，那么应该是 p[5] - p[1]，而不是 p[5] - p[2]。
